namespace CertLedgerBusinessSCTemplate.src.io.certledger.smartcontract
{
    public class CertificateFieldValidator
    {
        public static bool Validate(Certificate certificate)
        {
            Logger.log("Checking if Certificate is v3 Certificate");
            if (!IsVersion3(certificate))
            {
                Logger.log("Validation Error: Is Not v3 Certificate");
                return false;
            }

            Logger.log("Checking TBS Signature Algorithm is equal to Signature Algoritm");
            if (!SignatureAlgorithmFieldIsSameWithTBSCertificateSignatureAlgorithmField(certificate))
            {
                Logger.log(
                    "Validation Error: Signature Algorithm field is not same with TBS Signature Algorithm Field");
                Logger.log(certificate.TBSSignatureAlgorithm);
                Logger.log(certificate.SignatureAlgorithm);
                return false;
            }

            //todo: discuss about 
            /* if (!IsSerialNumberPositive(certificate))
             {
                 Logger.log("Validation Error: Serial Number is not positive");
                 return false;
             }
             */

            Logger.log("Checking If Subject Is Valid");
            if (!IsSubjectValid(certificate))
            {
                Logger.log("Validation Error: Certificate Subject is invalid");
                return false;
            }

            Logger.log("Checking If Issuer Is Empty");
            if (IsIssuerEmpty(certificate))
            {
                Logger.log("Validation Error: All Issuer Name Fields is empty or null");
                return false;
            }

            Logger.log("Checking Authority Key Identifier Extension");
            if (!ValidateAuthorityKeyIdentifier(certificate))
            {
                Logger.log("Validation Error: Authority Key Identifier Extension is invalid");
                return false;
            }

            if (!ValidateSubjectKeyIdentifier(certificate))
            {
                Logger.log("Validation Error: Subject Key Identifier Extension is invalid");
                return false;
            }

            Logger.log("Validating Key Usage");
            if (!ValidateKeyUsage(certificate))
            {
                Logger.log("Validation Error: Key Usage Extension is invalid");
                return false;
            }

            return true;
        }

        private static bool IsVersion3(Certificate certificate)
        {
            return certificate.Version == 3;
        }

        private static bool SignatureAlgorithmFieldIsSameWithTBSCertificateSignatureAlgorithmField(
            Certificate certificate)
        {
            return ArrayUtil.AreEqual(certificate.SignatureAlgorithm, certificate.TBSSignatureAlgorithm);
        }

        private static bool IsIssuerEmpty(Certificate certificate)
        {
            return certificate.Issuer.isEmpty;
        }

        private static bool ValidateAuthorityKeyIdentifier(Certificate certificate)
        {
            if (!certificate.BasicConstraints.IsCa)
            {
                if (certificate.AuthorityKeyIdentifier.keyIdentifier == null)
                {
                    Logger.log("Validation Error: Authority Key Identifier Extension must be present");
                    return false;
                }

                if (certificate.AuthorityKeyIdentifier.IsCritical)
                {
                    Logger.log("Validation Error: Authority Key Identifier Extension must be non-critical");
                    return false;
                }
            }

            //todo:
            /*
             *    Conforming CAs MUST mark this extension as non-critical.
             */
            /*
             * The keyIdentifier field of the authorityKeyIdentifier extension MUST
   be included in all certificates generated by conforming CAs to
   facilitate certification path construction.
             */
            return true;
        }

        private static bool ValidateSubjectKeyIdentifier(Certificate certificate)
        {
            if (certificate.SubjectKeyIdentifier.HasSubjectKeyIdentifierExtension)
            {
                if (certificate.SubjectKeyIdentifier.IsCritical)
                {
                    Logger.log("Validation Error: Subject Key Identifier Extension must be non-critical");
                    return false;
                }
            }

            //todo:
            /*
             *    Conforming CAs MUST mark this extension as non-critical.
             */
            /*
           To assist
   applications in identifying the appropriate end entity certificate,
   this extension SHOULD be included in all end entity certificates.
             */
            return true;
        }

        private static bool ValidateKeyUsage(Certificate certificate)
        {
            if (certificate.KeyUsage.HasKeyUsageExtension)
            {
                if (!certificate.KeyUsage.IsCritical)
                {
                    return false;
                    /*
                     *  When present, conforming CAs SHOULD mark this extension as critical.
                     */
                }
            }

            return true;
        }


        private static bool IsSubjectValid(Certificate certificate)
        {
            //todo: check rfc details
            /*
             * The subject field identifies the entity associated with the public
   key stored in the subject public key field.  The subject name MAY be
   carried in the subject field and/or the subjectAltName extension.  If
   the subject is a CA (e.g., the basic constraints extension, as
   discussed in Section 4.2.1.9, is present and the value of cA is
   TRUE), then the subject field MUST be populated with a non-empty
   distinguished name matching the contents of the issuer field (Section
   4.1.2.4) in all certificates issued by the subject CA.  If the
   subject is a CRL issuer (e.g., the key usage extension, as discussed
   in Section 4.2.1.3, is present and the value of cRLSign is TRUE),
Cooper, et al.              Standards Track                    [Page 23]
 
RFC 5280  PKIX Certificate and CRL Profile            May 2008
   then the subject field MUST be populated with a non-empty
   distinguished name matching the contents of the issuer field (Section
   5.1.2.3) in all CRLs issued by the subject CRL issuer.  If subject
   naming information is present only in the subjectAltName extension
   (e.g., a key bound only to an email address or URI), then the subject
   name MUST be an empty sequence and the subjectAltName extension MUST
   be critical.
             */
            /*
             * If
   the CA issues certificates with an empty sequence for the subject
   field, the CA MUST support the subject alternative name extension
             */
            return true;
        }
    }
}